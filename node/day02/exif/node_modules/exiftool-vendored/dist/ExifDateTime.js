"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var luxon_1 = require("luxon");
var DateTime_1 = require("./DateTime");
var Maybe_1 = require("./Maybe");
var String_1 = require("./String");
var Timezones_1 = require("./Timezones");
// Not in typings:
var FixedOffsetZone = require("luxon").FixedOffsetZone;
var unsetZoneOffset = -24 * 60;
var unsetZone = new FixedOffsetZone(unsetZoneOffset);
/**
 * Encodes an ExifDateTime with an optional tz offset in minutes.
 */
var ExifDateTime = /** @class */ (function () {
    function ExifDateTime(year, month, day, hour, minute, second, millisecond, tzoffsetMinutes, rawValue) {
        this.year = year;
        this.month = month;
        this.day = day;
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        this.millisecond = millisecond;
        this.tzoffsetMinutes = tzoffsetMinutes;
        this.rawValue = rawValue;
    }
    ExifDateTime.fromISO = function (iso, defaultZone, rawValue) {
        if (String_1.blank(iso))
            return undefined;
        return this.fromDateTime(luxon_1.DateTime.fromISO(iso, {
            setZone: true,
            zone: Maybe_1.orElse(defaultZone, unsetZone)
        }), Maybe_1.orElse(rawValue, iso));
    };
    /**
     * Try to parse a date-time string from EXIF. If there is not both a date and
     * a time component, returns `undefined`.
     *
     * @param text from EXIF metadata
     * @param defaultZone a "zone name" which may be IANA, like
     * "America/Los_Angeles", or an offset, like "UTC-3". See
     * `offsetMinutesToZoneName`.
     */
    ExifDateTime.fromEXIF = function (text, defaultZone) {
        var _this = this;
        if (String_1.blank(text))
            return undefined;
        return Maybe_1.firstDefinedThunk([
            function () { return _this.fromExifStrict(text, defaultZone); },
            function () { return _this.fromISO(text, defaultZone); },
            function () { return _this.fromExifLoose(text, defaultZone); }
        ]);
    };
    ExifDateTime.fromPatterns = function (text, fmts) {
        var _this = this;
        var s = String_1.toS(text).trim();
        var inputs = [s];
        // Some EXIF datetime will "over-specify" and include both the utc offset
        // *and* the "time zone abbreviation", like PST or PDT.
        // TZAs are between 2 (AT) and 5 (WEST) characters.
        // Unfortunately, luxon doesn't support regex.
        // We only want to strip off the TZA if it isn't "UTC" or "Z"
        if (null == s.match(/[.\d\s](utc|z)$/i)) {
            var noTza = s.replace(/ [a-z]{2,5}$/i, "");
            if (noTza !== s)
                inputs.push(noTza);
        }
        return Maybe_1.first(inputs, function (input) {
            return Maybe_1.first(fmts, function (_a) {
                var fmt = _a.fmt, fmtZone = _a.zone;
                return Maybe_1.map(luxon_1.DateTime.fromFormat(input, fmt, { setZone: true, zone: fmtZone }), function (dt) { return _this.fromDateTime(dt, s); });
            });
        });
    };
    ExifDateTime.fromExifStrict = function (text, defaultZone) {
        if (String_1.blank(text))
            return undefined;
        var zone = String_1.notBlank(defaultZone) ? defaultZone : unsetZone;
        return this.fromPatterns(text, [
            // if it specifies a zone, use it:
            { fmt: "y:M:d H:m:s.uZZ" },
            { fmt: "y:M:d H:m:sZZ" },
            // if it specifies UTC, use it:
            { fmt: "y:M:d H:m:s.u'Z'", zone: "utc" },
            { fmt: "y:M:d H:m:s'Z'", zone: "utc" },
            // Otherwise use the default zone:
            { fmt: "y:M:d H:m:s.u", zone: zone },
            { fmt: "y:M:d H:m:s", zone: zone }
        ]);
    };
    ExifDateTime.fromExifLoose = function (text, defaultZone) {
        if (String_1.blank(text))
            return undefined;
        var zone = String_1.notBlank(defaultZone) ? defaultZone : unsetZone;
        return this.fromPatterns(text, [
            // FWIW, the following are from actual datestamps seen in the wild:
            { fmt: "MMM d y H:m:sZZZ" },
            { fmt: "MMM d y H:m:s", zone: zone },
            { fmt: "MMM d y, H:m:sZZZ" },
            { fmt: "MMM d y, H:m:s", zone: zone },
            // Thu Oct 13 00:12:27 2016:
            { fmt: "ccc MMM d H:m:s yZZ" },
            { fmt: "ccc MMM d H:m:s y", zone: zone }
        ]);
    };
    ExifDateTime.fromDateTime = function (dt, rawValue) {
        if (dt == null ||
            !dt.isValid ||
            dt.toMillis() === 0 ||
            dt.year === 0 ||
            dt.year === 1) {
            return undefined;
        }
        return new ExifDateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.millisecond, dt.offset === unsetZoneOffset ? undefined : dt.offset, rawValue);
    };
    Object.defineProperty(ExifDateTime.prototype, "millis", {
        get: function () {
            return this.millisecond;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExifDateTime.prototype, "zone", {
        get: function () {
            return Timezones_1.offsetMinutesToZoneName(this.tzoffsetMinutes);
        },
        enumerable: true,
        configurable: true
    });
    ExifDateTime.prototype.toDateTime = function () {
        var o = {
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second
        };
        Maybe_1.map(this.millisecond, function (ea) { return (o.millisecond = ea); });
        Maybe_1.map(this.tzoffsetMinutes, function (ea) { return (o.zone = Timezones_1.offsetMinutesToZoneName(ea)); });
        return luxon_1.DateTime.fromObject(o);
    };
    ExifDateTime.prototype.toDate = function () {
        return this.toDateTime().toJSDate();
    };
    ExifDateTime.prototype.toISOString = function (options) {
        if (options === void 0) { options = {}; }
        return this.toDateTime().toISO(__assign({}, options, { includeOffset: this.tzoffsetMinutes != null }));
    };
    ExifDateTime.prototype.toExifString = function () {
        return DateTime_1.dateTimeToExif(this.toDateTime());
    };
    ExifDateTime.prototype.toString = function () {
        return this.toISOString();
    };
    return ExifDateTime;
}());
exports.ExifDateTime = ExifDateTime;
//# sourceMappingURL=ExifDateTime.js.map