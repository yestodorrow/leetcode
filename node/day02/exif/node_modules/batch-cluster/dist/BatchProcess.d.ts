/// <reference types="node" />
import * as _cp from "child_process";
import { BatchProcessObserver } from "./BatchProcessObserver";
import { InternalBatchProcessOptions } from "./InternalBatchProcessOptions";
import { Task } from "./Task";
/**
 * BatchProcess manages the care and feeding of a single child process.
 */
export declare class BatchProcess {
    readonly proc: _cp.ChildProcess;
    readonly opts: InternalBatchProcessOptions;
    readonly observer: BatchProcessObserver;
    readonly name: string;
    readonly start: number;
    private dead;
    private _taskCount;
    /**
     * not null if `this.end()` has been called, or this process is no longer in the
     * process table.
     */
    private _endPromise;
    /**
     * Supports non-polling notification of `proc.pid` leaving the process table.
     */
    private readonly _exited;
    /**
     * Should be undefined if this instance is not currently processing a task.
     */
    private currentTask;
    private currentTaskTimeout;
    private readonly streamDebouncer;
    private readonly startupTask;
    constructor(proc: _cp.ChildProcess, opts: InternalBatchProcessOptions, observer: BatchProcessObserver);
    readonly pid: number;
    readonly taskCount: number;
    readonly exited: boolean;
    readonly exitedPromise: Promise<void>;
    readonly ready: boolean;
    readonly idle: boolean;
    /**
     * @return true if the child process is in the process table
     */
    running(): Promise<boolean>;
    notRunning(): Promise<boolean>;
    /**
     * @return {boolean} true if `this.end()` has been requested or the child
     * process has exited.
     */
    ended(): Promise<boolean>;
    notEnded(): Promise<boolean>;
    execTask(task: Task<any>): boolean;
    /**
     * End this child process.
     *
     * @param gracefully Wait for any current task to be resolved or rejected before shutting down the child process.
     * @param source who called end() (used for logging)
     * @return Promise that will be resolved when the process has completed. Subsequent calls to end() will ignore the parameters and return the first endPromise.
     */
    end(gracefully: boolean | undefined, source: string): Promise<void>;
    private _end;
    private awaitNotRunning;
    private onTimeout;
    private onError;
    private onExit;
    private onStderr;
    private onStdout;
    private onData;
    private clearCurrentTask;
    private resolveCurrentTask;
}
