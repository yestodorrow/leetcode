export declare function delay(millis: number, unref?: boolean): Promise<void>;
/**
 * Run the given thunk until the promise is resolved to true, or the timeout
 * passes.
 */
export declare function until(f: () => boolean | Promise<boolean>, timeoutMs: number): Promise<boolean>;
/**
 * Return a function that will, at most, run the given function once at a time.
 * Calls that occur during prior calls will no-op.
 */
export declare function atMostOne<T>(f: () => Promise<T>): () => Promise<T | undefined>;
/**
 * Return a function that will only invoke the given thunk after all prior given
 * promises have resolved or rejected.
 */
export declare function serial<T>(): (f: () => Promise<T>) => Promise<T>;
/**
 * Return a thunk that will call the underlying thunk at most every `minDelayMs`
 * milliseconds. The thunk will accept a boolean, that, when set, will force the
 * underlying thunk to be called (mostly useful for tests)
 */
export declare function ratelimit<T>(f: () => T, minDelayMs: number): (force?: boolean | undefined) => T | undefined;
/**
 * @returns a function that accepts a thunk. The thunk will be debounced.
 */
export declare function debounce(timeoutMs: number): (f: () => any) => void;
